"use strict";
exports.__esModule = true;
exports.parseRow = void 0;
var buffer_1 = require("../buffer");
var types_1 = require("../../types");
var parseRow = function (socket, task, data, pos) {
    var mode = task.mode, parseInfo = task.parseInfo;
    if (mode === types_1.ResultMode.skip || parseInfo.skipNextValues)
        return;
    pos += 7;
    var row;
    if (mode === types_1.ResultMode.objects) {
        row = parseObjects(parseInfo.columnsCount, task.decodeTypes, parseInfo.types, parseInfo.names, data, pos);
    }
    else if (mode === types_1.ResultMode.arrays)
        row = parseArrays(parseInfo.columnsCount, task.decodeTypes, parseInfo.types, parseInfo.names, data, pos);
    else if (mode === types_1.ResultMode.value)
        return parseValue(parseInfo.columnsCount, task.decodeTypes, parseInfo.type, task, data, pos);
    if (parseInfo.resultNumber === 0)
        task.result.push(row);
    else
        task.result[parseInfo.resultNumber].push(row);
};
exports.parseRow = parseRow;
var parseObjects = function (columnsCount, decodeTypes, types, names, data, pos) {
    var row = {};
    for (var c = 0; c < columnsCount; c++) {
        var size = buffer_1.decodeInt32(data, pos);
        pos += 4;
        var value = void 0;
        if (size === -1) {
            value = null;
        }
        else {
            var decode = decodeTypes[types[c]];
            if (decode)
                value = decode(data, pos, size);
            else
                value = data.toString('utf8', pos, pos + size);
            pos += size;
        }
        ;
        row[names[c]] = value;
    }
    return row;
};
var parseArrays = function (columnsCount, decodeTypes, types, names, data, pos) {
    var row = new Array(columnsCount);
    for (var c = 0; c < columnsCount; c++) {
        var size = buffer_1.decodeInt32(data, pos);
        pos += 4;
        var value = void 0;
        if (size === -1) {
            value = null;
        }
        else {
            var decode = decodeTypes[types[c]];
            if (decode)
                value = decode(data, pos, size);
            else
                value = data.toString('utf8', pos, pos + size);
            pos += size;
        }
        ;
        row[c] = value;
    }
    return row;
};
var parseValue = function (columnsCount, decodeTypes, type, task, data, pos) {
    for (var c = 0; c < columnsCount; c++) {
        var size = buffer_1.decodeInt32(data, pos);
        pos += 4;
        var value = void 0;
        if (size === -1) {
            value = null;
        }
        else {
            var decode = decodeTypes[type];
            if (decode)
                value = decode(data, pos, size);
            else
                value = data.toString('utf8', pos, pos + size);
            pos += size;
        }
        if (task.parseInfo.resultNumber === 0)
            task.result = value;
        else
            task.result[task.parseInfo.resultNumber] = value;
        task.parseInfo.skipNextValues = true;
        return;
    }
};
