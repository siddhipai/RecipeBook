"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.connect = void 0;
var net_1 = require("net");
var tls_1 = __importDefault(require("tls"));
var types_1 = require("../types");
var error_1 = require("./error");
var buffer_1 = require("./buffer");
var messageHandler_1 = require("./messageHandler");
var task_1 = require("./task");
var checkSSLMessage = Buffer.alloc(8);
buffer_1.encodeInt32(checkSSLMessage, 0, 8);
buffer_1.encodeInt32(checkSSLMessage, 4, 80877103);
var SSLCode = 'S'.charCodeAt(0);
var versionBuf = Buffer.alloc(4);
buffer_1.encodeInt32(versionBuf, 0, 196608);
var Connect = /** @class */ (function () {
    function Connect(adapter, socket, settings) {
        this.adapter = adapter;
        this.socket = socket;
        this.settings = settings;
    }
    Connect.prototype.connect = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.socket.prepared = {};
            _this.addTask(resolve, reject);
            _this.socketConnect().then(function () { return _this.checkSSL(); });
        });
    };
    Connect.prototype.addTask = function (resolve, reject) {
        var adapter = this.adapter;
        var error = new error_1.PgError();
        var task = task_1.createTask({
            adapter: adapter,
            error: error,
            resolve: resolve,
            reject: reject,
            mode: types_1.ResultMode.skip,
            query: 'Startup message',
            decodeTypes: {},
            finish: this.finish
        });
        this.task = task;
        this.socket.task = task;
    };
    Connect.prototype.socketConnect = function () {
        var _this = this;
        var _a = this.settings, port = _a.port, host = _a.host;
        return new Promise(function (resolve) { return _this.socket.connect(port, host, resolve); });
    };
    Connect.prototype.checkSSL = function () {
        var _this = this;
        this.socket.write(checkSSLMessage);
        var listener = function (data) {
            _this.sslResponseHandler(data, listener);
        };
        this.socket.on('data', listener);
    };
    Connect.prototype.sslResponseHandler = function (data, listener) {
        var _this = this;
        var _a = this, socket = _a.socket, host = _a.settings.host;
        socket.removeListener('data', listener);
        var code = data[0];
        if (code === SSLCode) {
            var options = {
                socket: socket,
                checkServerIdentity: tls_1["default"].checkServerIdentity,
                rejectUnauthorized: false,
                servername: net_1.isIP(host) === 0 ? host : undefined
            };
            var task = this.socket.task;
            this.socket = tls_1["default"].connect(options, function () {
                return _this.sendStartupMessage();
            });
            this.socket.task = task;
            this.socket.prepared = {};
        }
        else {
            this.sendStartupMessage();
        }
    };
    Connect.prototype.sendStartupMessage = function () {
        var socket = this.socket;
        messageHandler_1.handleMessage(socket, this.settings);
        var _a = this.settings, user = _a.user, database = _a.database;
        var message = "user\0" + user + "\0database\0" + database + "\0\0";
        var len = 8 + Buffer.byteLength(message);
        var buf = Buffer.alloc(len);
        buffer_1.encodeInt32(buf, 0, len);
        versionBuf.copy(buf, 4);
        buf.fill(message, 8);
        socket.write(buf);
    };
    Connect.prototype.finish = function (socket, task) {
        socket.task = undefined;
        if (task.failed)
            task.reject(task.error);
        else {
            task.resolve(socket);
            task_1.next(task.adapter, socket);
        }
    };
    return Connect;
}());
var connect = function (adapter, socket, settings) { return new Connect(adapter, socket, settings).connect(); };
exports.connect = connect;
